// использование конструкторов и деструкторов
#include "exep_ex6.cpp"
#include <vector>

class X{
    File_ptr aa;
    Lock_ptr bb;

public:
    X(const char* x, const char * y): aa(x, "rw"), bb(y){}

};

/*Теперь, как и для локальных объектов, реализация C++ берет на себя все заботы
о деталях выполнения процесса (никаких дополнительных действий от
программиста не требуется). Например, если исключение возникнет после того, как прошла
инициализация аа, но до того, как создан йй, будет автоматически вызван
деструктор для аа (но не для bb).



Итак, где годится рассмотренная простая модель получения ресурсов, от программиста
 не требуется писать явный код обрабоки исключений*/

//Самым простым ресурсом является память. Например:

class Y{
    int *p;
    void init();
public:
    Y(int s){p = new int[s]; init();}
    ~Y(){delete[] p;}
    //......
};

//Такая практика распространена и может приводить к утечкам памяти.
// Если в init() будет сгенерирована исключение, то выделенная в конструкторе память не освобождается - деструктор не будет вызван,
//т.к. объект не будет сконструирован полностью. Вот более безопасный вариант:

class Z{
    std::vector<int> p;
    void init();
public:
    Z(int s): p(s) {init();}
    //......
};

/*Память, используемая вектором p, теперь находится под управлением типа
        vector. Если init() сгенерирует исключение, выделенная память будет (неявно)
освобождена вызовом деструктора для р*/