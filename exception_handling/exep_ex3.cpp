#include "exep_ex2.cpp"

void foo(){
    try{
        throw E();;
    }catch (H){
        //когда сюда попадем ?
    }
}

//обрабочик исключений будет вызван в следующих случаях
/*
 * 1) Если Н того же типа, что и Е (например exeption)
 * 2) если Н - однозначный базовый класс для Е
 * 3) Если Н и Е - указательные  типы, и [1] [2] справедливы для типов, на которые указывают указатели
 * 4) Если Н - это ссылка, и [1] или [2] справледливы для типа, на который Н ссылается
 */

//повторная генерация исключений (обозначается throw без указания выражения)

void h(){
    try{
        //код, который может генерировать математические исключения
    }catch (Mather){
        if (can_handle_completely){
            //происходит обработка Mather
            return;
        } else{
            //делаем то, что можем
            throw ; // повторно генерируем исключене
        }
    }
}

/*Повторная генерация исключения обозначается ключевым словом throw, за
        которым не указывается никакого выражения. Если пытаться выполнить такой
оператор в отсутствие исключений, то будет вызвана функция terminate ().
Компиляторы могут (но не всегда) предупреждать о таких ошибках.
Повторно сгенерированное исключение есть точная копия оригинального
        исключения, а не его часть, что была доступна как Matherr. Другими словами, если
было сгенерировано исключение типа Int_overflow, то функция, вызвавшая h(),
        может по-прежнему перехватывать исключение типа Int_overflow, несмотря на то, что
        в самой функции h () исключение перехвачено с типом Matherr.*/