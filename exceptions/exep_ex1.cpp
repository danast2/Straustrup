/*Часто исключения разбиваются на семейства. Это означает, что наследование
        может отражать такое структурирование исключений и помогать в их обработке.
Например, исключения в математической библиотеке могут быть организованы
        следующим образом:*/
class Mather{};
class Overflow: public Mather{};
class Underflow: public Mather{};
class Zerodivide: public Mather{};
//.....

//Это позволяет нам обрабатывать любое исключение как Mather, не заботясь о точном его типе. Например:

void func(){
    try{
        //....
    }catch (Overflow){
        //обработка Overflow или производных от него
    }catch (Mather){
        //обработка любых Mather, кроме Overflow
    }
}

/*Организация исключений в виде наследственной иерархии может быть полезна
для обеспечения надежности кода. Например, как бы вам пришлось обрабатывать
исключения математической библиотеки без представленной выше иерархии?
Ясно, что потребовалось бы занудное перечисление всех типов исключений:*/
void g ()
{
    try{
        //..........
    }
    catch (Overflow) {/*...*/}
    catch (Underflow) {/*...*/}
    catch (Zerodivide) {/*...*/}
}
