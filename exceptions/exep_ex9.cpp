// исключения в конструкторах

/*Исключения решают проблему индикации ошибок в работе конструкторов.
Ввиду того, что конструкторы не возвращают никаких значений, традиционными
        альтернативами исключений являются следующие подходы:
    1. Оставить создаваемый объект в нештатном состоянии, в надежде на проверку
его состояния пользователем.
    2. Установить значение нелокальной переменной (например, еггпо) для
индикации об ошибке в работе конструктора, в надежде на проверку ее значения
пользователем.
    3. Не выполнять инициализацию в конструкторах, оставив эту работу для
инициализирующих функций-членов, вызываемых пользователем до первого
использования объекта.
    4. Пометить объект как «непроинициализированный» и при первом вызове
функции-члена для этого объекта выполнить инициализацию уже в этой
функции (с вытекающими последствиями в случае невозможности
успешного завершения инициализации).*/

class Vector{
public:
    class Size{};

    enum {max = 32000};

    Vector(int sz){
        if(sz < 0 || max < sz) throw Size();
        //....
    }

};

//Код, создающий объекты типа Vector, может перехватывать ошибки Vector: : Size,
//чтобы сделать в этом случае что-нибудь осмысленное:

Vector* func(int i){
    try {
        Vector* p = new Vector(i);
        //.....
        return p;
    }catch (Vector::Size){
        //обработка ошибки с размером
    }
}

    /*Другими словами, главной задачей всех
технологий обработки ошибок является передача информации об ошибке из точки
ее возникновения в такую точку программы, где имеется достаточно сведений для
выполнения удобным и надежным способом процесса восстановления системы от
последствий возникновения ошибочных ситуаций.*/